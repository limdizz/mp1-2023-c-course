# Itertools

## Немного о задаче

Эта задача про фундаментальное понятие из С++ - итератор. Вы напишите простенькие функции, которые помогут прочувствовать указатели еще больше, и в будущем помогут вам освоить понятие итератора. :upside_down_face:

## Сразу про ограничение

В этой задаче вам запрещается сравнивать указатели на больше (`>`, `>=`) меньше (`<`, `<=`), вычитать из одного указателя другой (`p1` - `p2`), прибавлять к указателям числа (`p1 + 5`).

Почему так - обсудим на паре.

Разрешается использовать равенство (`==`) и нераветсво (`!=`), делать инкременты/декременты (`p++`, `p--`, `++p`, `--p`), разыменовывать их.

## Что должны делать функции

1. `Fill` - заполняет последовательность `[begin, end)` значением `value`
2. `Range` - для последовательности `[begin, end)` записывает значения `[0, end - begin)`
3. `Reverse` -  изменяет порядок следования элементов в диапазоне `[begin, end)`. Велик соблазн тут заиспользовать `<`, но помните об ограничениях :upside_down_face:
4. `PartialSum` - заполняет значения частичными суммами, т.е. для любого указателя `current` в пределах `[begin, end)` должна быть сумма элементов последовательности `[begin, current]`.
4. `Equal` - проверяет, равны ли последовательности `[begin1, end1)` и `[begin2, end2)`. Последовательности могут быть разной длины. В этом случае пусть число `n = min(end1 - begin1, begin2 - end2)`. Проверяйте на равенство последовательности `[begin1, begin1 + n)`, `[begin2, begin2 + n)`

5. `Includes` - Проверяет, содержится ли последовательность `[begin2, end2)` в последовательности `[begin1, end1)`.

6. `FindLast` - возвращает указатель на последний элемент последовательности `[begin end)` со значением `value`. Если такого нет, возвращайте `end`.

## Примечание

Вам может помочь фукнция `Swap` из задачи `hello-pointers`. Пользуйтесь тем, что уже реализовано вами.
